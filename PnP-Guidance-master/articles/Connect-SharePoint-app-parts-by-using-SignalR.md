
# 使用 SignalR 连接 SharePoint 外接程序部件
使用 SignalR 在 SharePoint 外接程序部件之间实施实时通信。

 **上次修改时间：** 2015年8月12日

 _ **适用范围：** SharePoint 2013?| SharePoint Add-ins?| SharePoint Online_

 **注释**  名称"SharePoint 相关应用程序"将更改为"SharePoint 外接程序"。在转换期间，某些 SharePoint 产品和 Visual Studio 工具的文档和 UI 仍可能使用术语"SharePoint 相关应用程序"。有关详细信息，请参阅 [Office 和 SharePoint 相关应用程序的新名称](05b07b04-6c8b-4b7e-bd86-e32c589dfead.md#bk_newname)。

[Core.ConnectedAppParts](https://github.com/OfficeDev/PnP/tree/dev/Samples/Core.ConnectedAppParts) 示例说明如何将提供程序托管的外接程序用作消息代理或聊天中心来发送或接收来自所有连接到此聊天中心的外接程序部件的消息。如果您正在将您的 SharePoint Web 部件转换为应用外接程序部件，并且需要外接程序部件相互通信，请使用此解决方案。
 **为改进此内容做贡献**
您可以获取最新的更新，或为改进 [Github 上的此文章](https://github.com/OfficeDev/PnP-Guidance/blob/master/articles/Connect-SharePoint-app-parts-by-using-SignalR.md)做贡献。您还可以为改进本示例以及 [GitHub 上的其他示例](https://github.com/OfficeDev/PnP)做贡献。有关示例的完整列表，请参阅 [模式和做法开发人员中心](http://dev.office.com/patterns-and-practices)。我们欢迎您做出 [贡献](https://github.com/OfficeDev/PnP/wiki/contributing-to-Office-365-developer-patterns-and-practices)。 

## 开始之前

若要开始，请从 GitHub 上的 [Office 365 开发人员模式和做法](https://github.com/OfficeDev/PnP/tree/dev)项目下载 [Core.ConnectedAppParts](https://msdn.microsoft.com/ZH-CN/library/dn957927.aspx) 示例外接程序。


## 使用 Core.ConnectedAppParts 外接程序

若要使用 SignalR 来查看两个外接程序部件通信的演示，请执行以下操作： 


1. 在您运行此外接程序并显示起始页时，选择"返回站点"。
    
2. 选择"设置">"添加页面"。
    
3. 在"新页面名称"中，输入"ConnectedAppParts"，然后选择"创建"。
    
4. 选择"插入">"应用外接程序件"。
    
5. 选择"连接部件 - 1">"添加"。
    
6. 选择"插入">"外接程序部件"。
    
7. 选择"连接部件 - 2">"添加"。
    
8. 选择"保存"。
    
9. 在"连接部件 - 1"中，输入"外接程序部件 1 的 Hello World"，然后选择"发送"。
    
10. 验证消息"外接程序部件 1 的 Hello World"在"连接部件 - 1"和"连接部件 - 2"外接程序部件中均显示。
    
在此代码示例中，Core.ConnectedAppParts 项目包含两个部署到主机 Web 的外接程序部件（ConnectedPartOne 和 ConnectedPartTwo）。ConnectedPartOne 和 ConnectedPartTwo 在 IFRAME 中运行。在 Pages\ConnectedPartOne.aspx 和 Pages\ConnectedPartTwo.aspx 的 Core.ConnectedAppPartsWeb 项目中定义 ConnectedPartOne 和 ConnectedPartTwo 的网页内容。这两个页面都在带有聊天中心 (ChatHub.cs) 的提供程序托管的外接程序中运行，并使用嵌入式 JavaScript 以实现以下目的：


1. 包括 SignalR jQuery 库。
    
2. 使用  **connection.chatHub** 连接到 SignalR 中心代理。
    
3. 使用  **chat.client.broadcastMessage** 定义一个函数来接收聊天中心所发送的广播消息。在本代码示例中，外接程序部件的名称和广播的消息都显示在 **讨论** 列表中。
    
4. 使用  **$.connection.hub.start().done** 启动到聊天中心的连接。建立连接后，在 **sendmessage** 按钮的 Click 事件上定义事件处理程序。此事件处理程序调用 **chat.server.send** 来发送外接程序部件的名称和由用户输入到聊天中心的消息。
    

 **注释**  本文中的代码按原样提供，不提供任何明示或暗示的担保，包括对特定用途适用性、适销性或不侵权的默示担保。




```
    <!--Script references. -->
    <!--Reference the jQuery library. -->
    <script src="../Scripts/jquery-1.6.4.min.js" ></script>
    <!--Reference the SignalR library. -->
    <script src="../Scripts/jquery.signalR-2.0.3.min.js"></script>
    <!--Reference the autogenerated SignalR hub script. -->
    <script src="../signalr/hubs"></script>
    <!--Add script to update the page and send messages.--> 
    <script type="text/javascript">
        $(function () {
            // Declare a proxy to reference the hub. 
            var chat = $.connection.chatHub;
            // Create a function that the hub can call to broadcast messages.
            chat.client.broadcastMessage = function (name, message) {
                // Html encode display name and message. 
                var encodedName = $('<div />').text(name).html();
                var encodedMsg = $('<div />').text(message).html();
                // Add the message to the page. 
                $('#discussion').append('<li><strong>' + encodedName
                    + '</strong>:&amp;nbsp;&amp;nbsp;' + encodedMsg + '</li>');
            };
            // Set initial focus to message input box.  
            $('#message').focus();
            // Start the connection.
            $.connection.hub.start().done(function () {
                $('#sendmessage').click(function () {
                    // Call the Send method on the hub. 
                    chat.server.send($('#displayname').val(), $('#message').val());
                    // Clear text box and reset focus for next comment. 
                    $('#message').val('').focus();
                });
            });
        });
    </script>
```

当 ConnectedPartOne.aspx 中的嵌入式 JavaScript 代码运行  **chat.server.send** 时，将会调用 ChatHub.cs 中的 **Send** 方法。ChatHub.cs 中的 **Send** 方法接收广播应用部件的名称和消息，然后使用 **Clients.All.broadcastMessage** 将信息广播至所有连接的外接程序部件。 **Clients.All.broadcastMessage** 使用 **chat.client.broadcastMessage** 调用之前定义的 JavaScript 函数（在所有连接的外接程序部件中）。




```C#
 public void Send(string name, string message)
        {
            // Call the broadcastMessage method to update the add-in parts.
            Clients.All.broadcastMessage(name, message);
        }
```


 **重要信息**  在本代码示例中，连接到聊天中心的所有外接程序部件接收通过聊天中心发送的所有消息。请根据会话 ID 考虑对消息进行筛选以确定哪些外接程序部件应接收哪些消息。


## 其他资源



- [Office 365 开发模式和做法解决方案指南](https://msdn.microsoft.com/library/office/dn904529.aspx)
    
- [SignalR 简介](http://www.asp.net/signalr/overview/getting-started/introduction-to-signalr)
    
- [教程：SignalR 2 入门](http://www.asp.net/signalr/overview/getting-started/tutorial-getting-started-with-signalr)
    
- [模式和做法开发人员中心](http://dev.office.com/patterns-and-practices)
    
